The syntax for a mutation looks like the following example:
mutation {
  addPost(title: "GraphQL Tutorial", body: "Let's learn GraphQL by first installing...") {
    _id
    title
    body
  }
}

In resolvers we define query and mutations separately
Here, the Mongoose User model creates a new user in the database with whatever is passed in as the args.
GraphQL actually has such error handling built in. for user verification

The back end now supports creating an account and logging in, but there's no way to remember who is logged in as other requests are made.
In the past, you've solved that problem with a combination of cookies and sessions, 
which ties a front-end ID to a record in the database.

After the record in the database is identified, properties can be added to a server-side session to remember that user's details.
Another solution for authentication is a JSON Web Token, or JWT, which is a JSON object that's been encoded into a tokenized string.

JSON Web Tokens are especially useful because they do the following things:

Contain all the data you need encoded into a single string.

Eliminate the need to save a session ID on the back end or in the database.

Decrease the amount of server-side resources needed to maintain authentication.

Can be generated anywhere and aren't tied to a single domain like cookies.

In your server folder, run the npm install jsonwebtoken command to add the JWT package to your project.
Next, find the folder called utils in the server directory. In this folder, create a new file called auth.js.
jsonwebtoken
The signToken() function expects a user object and will add that user's username, email, and _id properties to the token.
Optionally, tokens can be given an expiration date and a secret to sign the token with

The secret merely enables the server to verify whether it recognizes this token.
Now that we have a way to generate tokens, we need to update the GraphQL type definitions to include it. 
A token isn't part of the User model, though, so it doesn't make sense to add it to the User type definition.
In the resolvers.js file, import the signToken() function with the following line:
Next, update the two mutation resolvers to sign a token and return an object that combines the token with the user's data.

After receiving this token, the client can continue to send it with any other requests. 
The back end will then decode the token and know exactly who was making the request, 
because all of the user's information is saved on the token itself.

Of course, those capabilities haven't been implemented yet, but you can still decode the token to see for yourself. 
Copy it from the Playground, then visit the official JSON Web Token website (Links to an external site.) 
and scroll down to the Debugger section. 
Paste the token into the Encoded box on the left. The decoded JSON will appear on the right.

The JWT website knows which JSON data was stored on the token string because the encoding algorithm is universal. 
That's why you should never include sensitive data like a password on your tokens—and always sign your tokens with a secret.

If the client saves the JWT somewhere (like in localStorage), then the token can be included with certain requests for the back end to validate.
You can include the token with a request in the following ways:

As part of the body

In the query string (e.g., ?token=abc)

As an HTTP header


An HTTP header is best practice. For this very purpose, 
official authorization headers prevent cluttering the body and query string with data outside their scope.
Authorization: <type> <credentials>
The credentials in the preceding example would be the JWT. 
Because the credentials are a token and not something like a key-value pair, the type would be bearer.

For reference, the complete JSON object would look like the following code, replacing the given token with your token:
{
  "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVzZXJuYW1lIjoidGVzdGVyMiIsImVtYWlsIjoidGVzdDJAdGVzdC5jb20iLCJfaWQiOiI1ZWQ2OTIzOGY5MjllYjQzOGM2MjI0YmUifSwiaWF0IjoxNTkxMTMyMDM3LCJleHAiOjE1OTExMzkyMzd9.5TLfWZCsC7bzsmOQ58xHf5G6PCD8TQEkrdioBSkN2T4"
}


Let's actually build that me query to see this in action.
But wait, how is this method supposed to read the request headers?
By default, the headers aren't available to a resolver. 
Even though you can add a third parameter, commonly called context, to the method—e.g., (parent, args, context)—you must define what that context is.
Open the server.js file again and scroll down to the server variable declaration.
When you instantiate a new instance of ApolloServer, you can pass in a context method that's set to return whatever you want available in the resolvers.

const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: ({ req }) => req.headers
});
This would see the incoming request and return only the headers.
 On the resolver side, those headers would become the context parameter.

We'll need to perform some logic around the headers, though, like verifying the JWT.
It would be cumbersome to do this in every resolver. Sounds like a good use case for a middleware function!

In the utils/auth.js file, add the following method to the existing module.exports object:
This is where the secret becomes important.
If the secret on jwt.verify() doesn't match the secret that was used with jwt.sign(),
the object won't be decoded. When the JWT verification fails, an error is thrown.
Users with an invalid token should still be able to request and see all thoughts. 


hus, we wrapped the verify() method in a try...catch statement to mute the error.
We'll manually throw an authentication error on the resolver side when the need arises.


Then update the server variable declaration to look like the following code:
const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: authMiddleware
});


This ensures that every request performs an authentication check, 
and the updated request object will be passed to the resolvers as the context.

In resolvers.js, you'll need to update the me() method to check for the existence of context.user. 
If no context.user property exists, then we know that the user isn't authenticated and we can throw an AuthenticationError.

Be sure to include a valid token on the HTTP Headers. If successful, the response will include the user's _id, username, and email. 
Otherwise, if authentication fails, you'll see a "Not logged in" error message.

Note that addReaction() will return the parent Thought instead of the newly created Reaction.
The token includes the user's username, email, and _id properties, which become properties of 
context.user and can be used in the follow-up Thought.create() and User.findByIdAndUpdate() methods.

Reactions are stored as arrays on the Thought model, so you'll use the Mongo $push operator.
we can finish out the mutations with addFriend().
This mutation will look for an incoming friendId and add that to the current user's friends array.
A user can't be friends with the same person twice, though, hence why we're using the $addToSet 
operator instead of $push to prevent duplicate entries.

